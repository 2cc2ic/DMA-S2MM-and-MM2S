
`timescale 1 ns / 1 ps

	module User_DMA_v1_0_M_AXI_FULL_mm2s #
	(
		// Users to add parameters here

		// User parameters ends
		// Do not modify the parameters beyond this line

		// Base address of targeted slave
		parameter  C_M_TARGET_SLAVE_BASE_ADDR	= 32'h40000000,
		// Burst Length. Supports 1, 2, 4, 8, 16, 32, 64, 128, 256 burst lengths
		parameter integer C_M_AXI_BURST_LEN	= 16,
		// Thread ID Width
		parameter integer C_M_AXI_ID_WIDTH	= 1,
		// Width of Address Bus
		parameter integer C_M_AXI_ADDR_WIDTH	= 32,
		// Width of Data Bus
		parameter integer C_M_AXI_DATA_WIDTH	= 32,
		// Width of User Write Address Bus
		parameter integer C_M_AXI_AWUSER_WIDTH	= 0,
		// Width of User Read Address Bus
		parameter integer C_M_AXI_ARUSER_WIDTH	= 0,
		// Width of User Write Data Bus
		parameter integer C_M_AXI_WUSER_WIDTH	= 0,
		// Width of User Read Data Bus
		parameter integer C_M_AXI_RUSER_WIDTH	= 0,
		// Width of User Response Bus
		parameter integer C_M_AXI_BUSER_WIDTH	= 0
	)
	(
		// Users to add ports here

		input fifo_mm2s_full,
		input fifo_mm2s_almost_full,

		input [23:0] length_register,
		input [31:0] addr_register,

		// User ports ends
		// Do not modify the ports beyond this line

		// Initiate AXI transactions
		input wire  INIT_AXI_TXN,
		// Asserts when transaction is complete
		output wire  TXN_DONE,


		// Global Clock Signal.
		input wire  M_AXI_ACLK,
		// Global Reset Singal. This Signal is Active Low
		input wire  M_AXI_ARESETN,

		// Master Interface Read Address.
		output wire [C_M_AXI_ID_WIDTH-1 : 0] M_AXI_ARID,
		// Read address. This signal indicates the initial
    // address of a read burst transaction.
		output wire [C_M_AXI_ADDR_WIDTH-1 : 0] M_AXI_ARADDR,
		// Burst length. The burst length gives the exact number of transfers in a burst
		output wire [7 : 0] M_AXI_ARLEN,
		// Burst size. This signal indicates the size of each transfer in the burst
		output wire [2 : 0] M_AXI_ARSIZE,
		// Burst type. The burst type and the size information,
    // determine how the address for each transfer within the burst is calculated.
		output wire [1 : 0] M_AXI_ARBURST,
		// Lock type. Provides additional information about the
    // atomic characteristics of the transfer.
		output wire  M_AXI_ARLOCK,
		// Memory type. This signal indicates how transactions
    // are required to progress through a system.
		output wire [3 : 0] M_AXI_ARCACHE,
		// Protection type. This signal indicates the privilege
    // and security level of the transaction, and whether
    // the transaction is a data access or an instruction access.
		output wire [2 : 0] M_AXI_ARPROT,
		// Quality of Service, QoS identifier sent for each read transaction
		output wire [3 : 0] M_AXI_ARQOS,
		// Optional User-defined signal in the read address channel.
		output wire [C_M_AXI_ARUSER_WIDTH-1 : 0] M_AXI_ARUSER,
		// Write address valid. This signal indicates that
    // the channel is signaling valid read address and control information
		output wire  M_AXI_ARVALID,
		// Read address ready. This signal indicates that
    // the slave is ready to accept an address and associated control signals
		input wire  M_AXI_ARREADY,
		// Read ID tag. This signal is the identification tag
    // for the read data group of signals generated by the slave.
		input wire [C_M_AXI_ID_WIDTH-1 : 0] M_AXI_RID,
		// Master Read Data
		// input wire [C_M_AXI_DATA_WIDTH-1 : 0] M_AXI_RDATA,
		// Read response. This signal indicates the status of the read transfer
		input wire [1 : 0] M_AXI_RRESP,
		// Read last. This signal indicates the last transfer in a read burst
		input wire  M_AXI_RLAST,
		// Optional User-defined signal in the read address channel.
		input wire [C_M_AXI_RUSER_WIDTH-1 : 0] M_AXI_RUSER,
		// Read valid. This signal indicates that the channel
    // is signaling the required read data.
		input wire  M_AXI_RVALID,
		// Read ready. This signal indicates that the master can
    // accept the read data and response information.
		output wire  M_AXI_RREADY
	);

	  function integer clogb2 (input integer bit_depth);
	  begin
	    for(clogb2=0; bit_depth>0; clogb2=clogb2+1)
	      bit_depth = bit_depth >> 1;
	    end
	  endfunction

	reg all_done;
	reg [3:0] state_ctrl;
	reg [23:0] burst_count;
	wire init_state_signal;
    reg [23:0] len_r_ff,len_r_state;
    reg [31:0] addr_r_ff,addr_r_state;

	reg [C_M_AXI_ADDR_WIDTH-1 : 0] 	axi_araddr;
	reg  	axi_arvalid;
	reg  	axi_rready;

	reg [4 : 0] 	read_index;

	wire [6 : 0] 	burst_size_bytes;

	reg [23 : 0] 	read_burst_counter;

	reg  	start_single_burst_read;

	reg  	reads_done;

	reg  	burst_read_active;

	wire  rnext;

	reg  	init_txn_ff;
	reg  	init_txn_ff2;
	reg  	init_txn_edge;
	reg  init_txn_pulse;

	reg [7:0] burst_len;

	assign M_AXI_ARID	= 'b0;
	assign M_AXI_ARADDR	= addr_r_state + axi_araddr;
	assign M_AXI_ARLEN	= burst_len - 1;
	assign M_AXI_ARSIZE	= clogb2((C_M_AXI_DATA_WIDTH/8)-1);
	assign M_AXI_ARBURST	= 2'b01;
	assign M_AXI_ARLOCK	= 1'b0;
	assign M_AXI_ARCACHE	= 4'b0010;
	assign M_AXI_ARPROT	= 3'h0;
	assign M_AXI_ARQOS	= 4'h0;
	assign M_AXI_ARUSER	= 'b1;
	assign M_AXI_ARVALID	= axi_arvalid;
	assign M_AXI_RREADY	= axi_rready;
	assign TXN_DONE	= all_done;
	assign burst_size_bytes	= burst_len << 2; //C_M_AXI_DATA_WIDTH/8

	  always @(posedge M_AXI_ACLK)
	  begin

	    if (M_AXI_ARESETN == 0 || init_txn_pulse == 1'b1 )
	      begin
	        axi_arvalid <= 1'b0;
	      end
	    else if (~axi_arvalid && start_single_burst_read)
	      begin
	        axi_arvalid <= 1'b1;
	      end
	    else if (M_AXI_ARREADY && axi_arvalid)
	      begin
	        axi_arvalid <= 1'b0;
	      end
	    else
	      axi_arvalid <= axi_arvalid;
	  end

	  always @(posedge M_AXI_ACLK)
	  begin
	    if (M_AXI_ARESETN == 0 || init_state_signal == 1'b1)
	      begin
	        axi_araddr <= 'b0;
	      end
	    else if (M_AXI_ARREADY && axi_arvalid)
	      begin
	        axi_araddr <= axi_araddr + burst_size_bytes;
	      end
	    else
	      axi_araddr <= axi_araddr;
	  end

	  assign rnext = M_AXI_RVALID && axi_rready;

	  always @(posedge M_AXI_ACLK)
	  begin
	    if (M_AXI_ARESETN == 0 || init_txn_pulse == 1'b1 || start_single_burst_read)
	      begin
	        read_index <= 0;
	      end
	    else if (rnext && (read_index != (burst_len-1) ))
	      begin
	        read_index <= read_index + 1;
	      end
	    else
	      read_index <= read_index;
	  end

	  always @(posedge M_AXI_ACLK)
	  begin
	    if (M_AXI_ARESETN == 0 || init_txn_pulse == 1'b1 )
	      begin
	        axi_rready <= 1'b0;
	      end
	    else if (M_AXI_RVALID)
	      begin
            if (fifo_mm2s_full)
              begin
                axi_rready <= 1'b0;
              end
            else if (fifo_mm2s_almost_full && rnext)
              begin
                axi_rready <= 1'b0;
              end
	        else if (M_AXI_RLAST && axi_rready)
	          begin
	            axi_rready <= 1'b0;
	          end
	        else
	          begin
	            axi_rready <= 1'b1;
	          end
	      end
	  end

	  always @(posedge M_AXI_ACLK)
	  begin
	    if (M_AXI_ARESETN == 0 || init_txn_pulse == 1'b1)
	      begin
	        read_burst_counter <= 'b0;
	      end
	    else if (M_AXI_ARREADY && axi_arvalid)
	      begin
	        if (burst_count != read_burst_counter)
	          begin
	            read_burst_counter <= read_burst_counter + 1'b1;
	          end
	      end
	    else
	      read_burst_counter <= read_burst_counter;
	  end

	  always @(posedge M_AXI_ACLK)
	  begin
	    if (M_AXI_ARESETN == 0 || init_txn_pulse == 1'b1)
	      burst_read_active <= 1'b0;
	    else if (start_single_burst_read)
	      burst_read_active <= 1'b1;
	    else if (M_AXI_RVALID && axi_rready && M_AXI_RLAST)
	      burst_read_active <= 0;
	    end

	  always @(posedge M_AXI_ACLK)
	  begin
	    if (M_AXI_ARESETN == 0 || init_txn_pulse == 1'b1)
	      reads_done <= 1'b0;
	    else if (M_AXI_RVALID && axi_rready && (read_index == burst_len-1) && (burst_count == read_burst_counter) )
	      reads_done <= 1'b1;
	    else
	      reads_done <= reads_done;
	    end

	// Add user logic here


	always @(posedge M_AXI_ACLK)
	  begin
	    if (M_AXI_ARESETN == 0 )
	      begin
	        init_txn_ff <= 1'b0;
	        init_txn_ff2 <= 1'b0;
	      end
	    else
	      begin
	        init_txn_ff <= INIT_AXI_TXN;
	        init_txn_ff2 <= init_txn_ff;
	      end
	  end

	assign init_state_signal	= (!init_txn_ff2) && init_txn_ff;

	always @(posedge M_AXI_ACLK)
	  begin
	    if (M_AXI_ARESETN == 0 )
	      begin
	        len_r_ff  <= 0;
					addr_r_ff <= 0;
	      end
	    else
	      begin
	        len_r_ff  <= length_register;
					addr_r_ff <= addr_register;
	      end
	  end

	always @(posedge M_AXI_ACLK)
	  begin
	    if (M_AXI_ARESETN == 0 )
	      begin
					state_ctrl <= 0;

					len_r_state <= 0;
					addr_r_state <= 0;

					burst_len <= 0;
					burst_count <= 0;

					init_txn_pulse <=0;
					all_done <= 0;

	      end
	    else
	      begin
					case (state_ctrl)

						0:
						begin
							if ( init_state_signal == 1'b1)
								begin
									state_ctrl  <= state_ctrl + 1;

									len_r_state <= len_r_ff;
									addr_r_state <= addr_r_ff;

									burst_len <= 0;

									all_done <= 0;
								end
							else
								begin
									state_ctrl  <= state_ctrl;
								end
						end

						1:
						begin
							if(len_r_state[23:4] == 20'd0)
								begin
									state_ctrl <= state_ctrl + 3;
								end
							else
								begin
									state_ctrl <= state_ctrl + 1;
									burst_len <= 16;
									burst_count <= len_r_state[23:4];
								end
						end

						2:
						begin
							if(init_txn_pulse)
								begin
									init_txn_pulse <= 0;
									state_ctrl <= state_ctrl + 1;
								end
							else
								begin
									init_txn_pulse <= 1;
									state_ctrl <= state_ctrl;
								end
						end

						3:
						begin
							if(reads_done)
								begin
									state_ctrl <= state_ctrl + 1;
								end
							else
								begin
									state_ctrl <= state_ctrl;
								end
						end

						4:
						begin
							if(len_r_state[3])
								begin
									state_ctrl <= state_ctrl + 1;
									burst_len <= 8;
									burst_count <= 1;
								end
							else
								begin
									state_ctrl <= state_ctrl + 3;
								end
						end

						5:
						begin
							if(init_txn_pulse)
								begin
									init_txn_pulse <= 0;
									state_ctrl <= state_ctrl + 1;
								end
							else
								begin
									init_txn_pulse <= 1;
									state_ctrl <= state_ctrl;
								end
						end

						6:
						begin
							if(reads_done)
								begin
									state_ctrl <= state_ctrl + 1;
								end
							else
								begin
									state_ctrl <= state_ctrl;
								end
						end

						7:
						begin
							if(len_r_state[2])
								begin
									state_ctrl <= state_ctrl + 1;
									burst_len <= 4;
									burst_count <= 1;
								end
							else
								begin
									state_ctrl <= state_ctrl + 3;
								end
						end

						8:
						begin
							if(init_txn_pulse)
								begin
									init_txn_pulse <= 0;
									state_ctrl <= state_ctrl + 1;
								end
							else
								begin
									init_txn_pulse <= 1;
									state_ctrl <= state_ctrl;
								end
						end

						9:
						begin
							if(reads_done)
								begin
									state_ctrl <= state_ctrl + 1;
								end
							else
								begin
									state_ctrl <= state_ctrl;
								end
						end

						10:
						begin
							if(len_r_state[1])
								begin
									state_ctrl <= state_ctrl + 1;
									burst_len <= 2;
									burst_count <= 1;
								end
							else
								begin
									state_ctrl <= state_ctrl + 3;
								end
						end

						11:
						begin
							if(init_txn_pulse)
								begin
									init_txn_pulse <= 0;
									state_ctrl <= state_ctrl + 1;
								end
							else
								begin
									init_txn_pulse <= 1;
									state_ctrl <= state_ctrl;
								end
						end

						12:
						begin
							if(reads_done)
								begin
									state_ctrl <= state_ctrl + 1;
								end
							else
								begin
									state_ctrl <= state_ctrl;
								end
						end

						13:
						begin
							if(len_r_state[0])
								begin
									state_ctrl <= state_ctrl + 1;
									burst_len <= 1;
									burst_count <= 1;
								end
							else
								begin
									state_ctrl <= 0;
									all_done   <= 1;
								end
						end

						14:
						begin
							if(init_txn_pulse)
								begin
									init_txn_pulse <= 0;
									state_ctrl <= state_ctrl + 1;
								end
							else
								begin
									init_txn_pulse <= 1;
									state_ctrl <= state_ctrl;
								end
						end

						15:
						begin
							if(reads_done)
								begin
									state_ctrl <= 0;
									all_done <= 1;
								end
							else
								begin
									state_ctrl <= state_ctrl;
								end
						end

					default:
						begin

						end
					endcase
	      end
	  end

		reg state_read;

	always @ ( posedge M_AXI_ACLK)
	begin
		if (M_AXI_ARESETN == 1'b0 )
			begin
				state_read <= 0;
				start_single_burst_read  <= 1'b0;
			end
		else
			begin
				case (state_read)

					0:
					begin
						if ( init_txn_pulse == 1'b1)
							begin
								state_read  <= 1;
							end
						else
							begin
								state_read  <= state_read;
							end
					end

					1:
					begin
						if (reads_done)
							begin
								state_read <= 0;
							end
						else
							begin
								state_read  <= state_read;

								if (~axi_arvalid && ~burst_read_active && ~start_single_burst_read)
									begin
										start_single_burst_read <= 1'b1;
									end
							 else
								 begin
									 start_single_burst_read <= 1'b0;
								 end
							end
					end

					default :
						begin
							state_read  <= 0;
						end
				endcase
			end
	end

	// User logic ends

	endmodule
